---
title: "Professional Precis Collection"
toc: true
page-layout: full
---

## Software Engineering at Google

### Preface - Programming Over Time

As the preface, there isn't a lot of content in this segment. It outlines the
authors' goals to present the ideas of the difference between software engineering
and programming, namely that software engineering is over a longer period of time.
Part of this is in outlining the key ideas(Time and Change, Scale and Growth,
Trade-Offs and Costs) and part is from the presented equation of software engineering
as "programming integratd over time".

This proposes that for a team starting out, it can be good to build a base that
anticipates and prepares for a changing and developing project from the beginning.
This is part of making a project sustainable, and therefore useful for as long as
possible. 

### What Is Software Engineering?

This chapter not only goes in depth about the differences between software
engineering and programming proposed in the preface, but also about the principles
of effective software engineering. These principles are much more based in what
actions need to be taken by the engineers/project at large, as part of that
distinction between programming and software engineering; the latter is much
more based on longevity and therefore on the maintenance and upkeep required
to create it. Some of these included just implementing standard practices for
checks and for taking certain actions/making decisions, and others include
warning against allowing problems to build up and advising awareness.

The chapter goes in much greater depth on all these points, of course. From this
I think it would be wise to take the key understandings to heart. In particular,
I feel that policy creation and making systems that inform how to complete tasks
is a particularly useful idea for our current, and presumably next, projects as
a team. 

### How to Work Well In Teams

This chapter begins by highlighting the insecurity inherent to creation; the
desire to hide and create alone until your project is perfect in order to minimize
&mdash; or perhaps avoid entirely &mdash; the judgement of others. It then points
out the flaws within this process, as it reduces the opportunities for flaw
detection and for pooling many different types of expertise to resolve those, as
well as improve on the initial design. Many hands make light work, another element
of teamwork to aid in project completion.
Knowing that isolation doesn't work is only half the battle, so the chapter then
details how to encourage proper teamwork, starting with oneself. It particularly
highlights three values; humility, respect, and trust. Through the cultivation
of these three traits, a good team&mdash;centered perspective and attitude can
be created.

While I've been in a variety of teams and taken leadership courses, it never
hurts to review the basics. It gives me an opportunity to review what has been
done so far and where I can improve in maintaining the ideals and strategies of
working with other people.

## Fuzzing Book

### Introduction to Software Testing

This chapter uses a square root function as an example for what to test and how
to go about testing functions. It covers the `assert` keyword, as well as basic
the basic mathematic properties that go into developing the tests, and how to
translate that into a test function/case. The chapter goes on to discuss the
`Timer` module in relation to optimizing tests as well. From there, further
optimization is discussed in the form of automatic run-time checks, in order
to check the function each time it is run, with any input. This segues into
a discussion on how effective this is as an optimization, bringing up the time
and system expense at running such checks, and other such limits involved in
running tests and attempts to ensure correctness.

While none of this information is new to me personally, it is valuable to
reflect on before starting a new project, or even at any point in the process
of one. Testing and test cases are what ensures that a program or code segment
will work and serve its purpose, as well as allowing experimentation with
optimizing the code with the tests to fall back on for checks. A reminder of
the tools that aid in doing that is also helpful to make sure one does not try
and take the long way around in creating tests, and testing the tests.

### Code Coverage

This chapter goes into detail about the coverage of tests. It opens mainly with
comparing black-box testing and white-box testing, with black-box testing being
that which focuses on specifying what it should be, and white-box testing instead
checking the implementation of the code. This means that while black-box testing
can be prepared before implementing, it might miss some errors/code that only
occurs in implementation. From there it goes on to discuss the option in Python
to run a system function(`sys.settrace(f)`) in order to trace code and
automatically test, as a dynamic analysis. From this command the book breaks
down the steps to using it to assess coverage as well. The next section outlines
how to make this process more efficient using the `with` keyword and
functionality. After covering this topic at length, it also discusses other
programming languages, going into automated test coverage for C. It is then
detailed that proper coverage does not guarantee error-free code, but using
oracle tests and/or fuzzing can help get closer to that ideal.

From this I think it is important to take the understanding of not only how to
automate the test creation and coverage checking, but also the distinctions in
tests. Knowing which test is most effective, and when something cannot(or should
not) be automated is important as well. Mostly, though, I think that it serves as
both a reinforcement of the knowledge that you cannot guarantee perfect code even
with tests and also all the ways in which you can try, as well as how to use them.

### Fuzzing: Breaking Things With Random Inputs

This chapter goes in depth on the history of fuzzing tests, their creation, and
their applications both on their own and in conjunction with other forms of
testing. A fuzzer, or a fuzzing test, is the generation of a large amount of
random inputs to see how well the function or program can hold up with that.
It's a larger scale version of intentionally putting in what one knows are risky
inputs to try to 'break' the program, to test its robustness. With this
established, the chapter goes on to show the creation of increasingly complex
implementations of fuzzers. Part of this discussion is going over some common
and/or major bugs and design flaws that can create an assortment of both
security and general issues. This leads into an explanation on the interaction
between other types of checks with fuzzers, and how they can interact to create
more robust test cases. This also serves to acknowledge areas in which other
checks serve better or as more of a first line of defense. With all of this
established, there is then a discussion of a `Fuzzing Architecture`, showing
the practical application of the concepts discussed.

The application of this for projects is quite clear. By implementing a robust
test structure, including fuzzers to help identify as manner weak points as
possible, one can create more reliable code both for running and for security.
The earlier this is in place, the better, as it may catch issues with underlying
structures that need to be altered to better suit the goal. This will help
remove an assortment of issues that otherwise plague programmers and their
software.

## Debugging Book